m := make(map[string]string)    // создаём map — о применении функции make для создания переменных типа map будет рассказано ниже
m["foo"] = "bar"        // заполняем парами «ключ-значение»
m["ping"] = "pong"        
fmt.Println(m)            // печатаем 

// output:
// map[foo:bar ping:pong]


// Чтобы объект ссылочного типа можно было использовать, его нужно сначала создать (инициализировать) встроенной функцией make():
type MyMap map[string] string

var m1 MyMap
m1 = make(MyMap, 5)

// объект готов
m1["foo"] = "bar" 
// Встроенная функция make() — универсальный конструктор объектов ссылочного типа, она применяется для создания объектов всех ссылочных типов.


// Для map composite literal выглядит так:
MyMap := map[KeyType]ValueType{key1: value1, key2: value2, ... , keyN: valueN,}
// например
MyStringMap := map[string]string{"first": "первый", "second": "второй",} 
// В данном случае композитный литерал создаёт map без использования функции make и уже с инициализированными парами «ключ-значение».


// Синтаксис map
// Значения для ключей устанавливаются оператором присваивания:
m[key] = value 
// А извлекаются индексным выражением:
v, ok = m[k]
v, ok := m[k]
var v, ok = m[k] 

// Можно использовать простую форму индексного выражения:
v = m[k] 
// В такой форме выражение обязательно возвращает:
// значение, привязанное к ключу k, если такое существует;
// в противном случае — нулевое значение типа.
// Если сделать 
// m := make(map[int]int), не заполнить данными и всё же запросить значение ключа 100 v :=  m[100], запрос будет отработан и вернёт значение 0 (нулевое значение для типа int).
// Если присвоить значение ключу 50 m[50] = 0 и запросить его v := m[50], ответ будет таким же — 0.
// Это два разных случая:
// ключу не назначено значение;
// ключу назначено нулевое значение.
// Чтобы различать их, лучше пользоваться полной формой индексного выражения: v, ok = m[k]. Тогда переменная ok примет значение true, если ключ найден, и false в противном случае.


// Встроенные функции для типа map

var m1 map[int]int
m2 := map[int]int{1: 10, 2: 20, 3: 30}
fmt.Println(len(m1), len(m2)) 

// 0 3

// Использование в циклах range
// map можно использовать в цикле for c итератором range.
// Для этого предусмотрен удобный синтаксис:
m := make(map[string]string)
m["foo"] = "bar"
m["bazz"] = "yup"
for k, v := range m {
    // k будет перебирать ключи,
    // v — соответствующие этим ключам значения
    fmt.Printf("Ключ %v, имеет значение %v \n", k, v)
} 

// Если нужна модификация таблицы, лучше сделать так:
for k, v := range m {
    m[k] = "here key "+k    // применяем к таблице индексное выражение
                // и модифицируем её прямым доступом к ячейкам  
} 



// Сделайте map для хранения прейскуранта в рублях:
// хлеб — 50,
// молоко — 100,
// масло — 200,
// колбаса — 500,
// соль — 20,
// огурцы — 200,
// сыр — 600,
// ветчина — 700,
// буженина — 900,
// помидоры — 250,
// рыба — 300,
// хамон — 1500.
// Выведите перечень деликатесов — продуктов дороже 500 рублей.
// Заказ выдан слайсом []string{"хлеб", "буженина", "сыр", "огурцы"}. Посчитайте стоимость заказа.


pricelist := map[string]int{"хлеб": 50, "молоко": 100, "масло": 200, "колбаса": 500, "соль": 20, "огурцы": 200, "сыр": 600, "ветчина": 700, "буженина": 900, "помидоры": 250, "рыба": 300, "хамон": 1500,}
order := []string{"хлеб", "буженина", "сыр", "огурцы"}
total := 0
fmt.Println("Перечень деликатесов:")
for k, v := range pricelist{
    if v > 500{
        fmt.Println(k)
    }
}
for _, v := range order{
    total += pricelist[v]
}
fmt.Println("Стоимость заказа ", total)



// Ассоциативные массивы широко применяются при решении алгоритмических задач. 
// Когда количество данных более нескольких десятков, поиск значения в map происходит эффективнее, чем в массиве.
// Опираясь на эту информацию, попробуйте решить следующую задачу, которую часто предлагают на собеседованиях.
// Дан массив целых чисел A и целое число k. Нужно найти и вывести индексы пары чисел, сумма которых равна k. 
// Если таких чисел нет, то вернуть пустой слайс. Индексы можно вернуть в любом порядке.

    
func find(arr []int, k int) []int {
	// Создадим пустую map  
	m := make(map[int]int)
	// будем складывать в неё индексы массива, а в качестве ключей использовать само значение 
	for i, a := range arr {
		if j, ok := m[k-a]; ok { // если значение k-a уже есть в массиве, значит, arr[j] + arr[i] = k и мы нашли, то что нужно
			return []int{i,j}
		}
		// если искомого значения нет, то добавляем текущий индекс и значение в map
		m[a] = i
	}
	// не нашли пары подходящих чисел
	return nil
}    
// как можно заметить, алгоритм пройдётся по массиву всего один раз
// если бы мы искали подходящее значение каждый раз через перебор массива, то пришлось бы сделать гораздо больше вычислений


// Дедупликация строк
// Представьте, что на входе есть слайс строк:
input := []string{
    "cat",
    "dog",
    "bird",
    "dog",
    "parrot",
    "cat",
} 
// Напишите функцию, которая убирает дубликаты, сохраняя порядок слайса:

package main

import "fmt"

func RemoveDuplicates(input []string) []string {
    output := make([]string, len(input))
    copy(output, input)

    inputSet := make(map[string]struct{}, len(input))
    outputIdx := 0
    for _, v := range input {
        if _, ok := inputSet[v]; !ok {
            output[outputIdx] = v
            outputIdx++
        }
        inputSet[v] = struct{}{}
    }

    return output[:outputIdx]
}

func main() {
    input := []string{
        "cat",
        "dog",
        "bird",
        "dog",
        "parrot",
        "cat",
    }
    fmt.Println(input)

    fmt.Println(RemoveDuplicates(input))
} 