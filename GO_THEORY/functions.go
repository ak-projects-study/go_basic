// Вот функция, которая находит индекс буквы в строке и возвращает вторым аргументом false, если буква не найдена:
func Index(st string, a rune) (index int, ok bool) {
  for i, c := range st {
    if c == a {
      return i, true
    }
  }
    return // вернутся значения по умолчанию
} 


// Вот хрестоматийный пример рекурсивного вычисления n!, факториала числа:
func fact(n int) int {
    if n == 0 {    // терминальная ветка — то есть условие выхода из рекурсии
        return 1
    } else {    // рекурсивная ветка 
        return n * fact(n-1)
    }
} 


// А вот числа Фибоначчи:
func Fib(n int) int {
    switch {
    case n <= 1:    // терминальная ветка 
        return n
    default:        // рекурсивная ветка
        return Fib(n-1) + Fib(n-2)
    }
} 


// Итеративные алгоритмы будут работать быстрее. Для сравнения приведём итеративную реализацию (на основе циклов) вышеуказанных примеров:
func fact(n int) int {
    res := 1
    for n > 0 {
        res *= n
        n--
    }
    return res
} 
func Fib(n int) int {
    a, b := 0, 1
    for n > 0 {
        a, b = b, a+b
        n--
    }
    return a
} 



// Приведём пример работы с рекурсивным обходом всех файлов в данной директории, 
// причём директория может содержать вложенные поддиректории:

func main() {
	PrintAllFilesWithFilter(".", "lesson")
	PrintAllFilesWithFilter(".", "Functions")
	}
	
	func PrintAllFilesWithFilter(path string, filter string) {
		// получаем список всех элементов в папке (и файлов, и директорий)
		files, err := ioutil.ReadDir(path)
		if err != nil {
			fmt.Println("unable to get list of files", err)
			return
		}
		//  проходим по списку
		for _, f := range files {
			// получаем имя элемента
			// filepath.Join — функция, которая собирает путь к элементу с разделителями
			filename := filepath.Join(path, f.Name())
			// печатаем имя элемента, если путь к нему содержит filter
			if strings.Contains(filename, filter) {
				fmt.Println(filename)
			}
			// если элемент — директория, то вызываем для него рекурсивно ту же функцию
			if f.IsDir() {
				PrintAllFilesWithFilter(filename, filter)
			}
	}
	}

	// На основе функции PrintAllFiles из предыдущего примера реализуйте функцию PrintAllFilesWithFilter(path string, filter string), 
	// которая будет печатать только путь со строкой filter.
	func main() {
		PrintAllFilesWithFilter(".", "lesson")
		PrintAllFilesWithFilter(".", "Functions")
		}
		
		func PrintAllFilesWithFilter(path string, filter string) {
			// получаем список всех элементов в папке (и файлов, и директорий)
			files, err := ioutil.ReadDir(path)
			if err != nil {
				fmt.Println("unable to get list of files", err)
				return
			}
			//  проходим по списку
			for _, f := range files {
				// получаем имя элемента
				// filepath.Join — функция, которая собирает путь к элементу с разделителями
				filename := filepath.Join(path, f.Name())
				// печатаем имя элемента, если путь к нему содержит filter
				if strings.Contains(filename, filter) {
					fmt.Println(filename)
				}
				// если элемент — директория, то вызываем для него рекурсивно ту же функцию
				if f.IsDir() {
					PrintAllFilesWithFilter(filename, filter)
				}
		}
		}



// Функция первого класса
// Функции в Go ничем не уступают другим классам объектов. У функции есть тип и значение. Функцию можно присвоить переменной, можно передать аргументом другой функции. 
// Функция может возвращать в качестве значения другую функцию.
// Тип функции виден в её сигнатуре, то есть определяется как набор типов и количества аргументов, возвращаемых значений.
// Например, эта функция
func Say(animal string) (v string) {
    switch animal {
    default:
        v = "heh"
    case "dog":
        v = "gav"
    case "cat":
        v = "myau"
    case "cow":
        v = "mu"
    }
    return
} 
// имеет тип:
func(string) string 
// Можно присвоить её переменной такого типа:
var voice func(string) string
voice = Say 
// Можно написать функцию высшего порядка с параметром такого типа:
func Print(who string, how func(string) string){
    fmt.Println(how(who))
} 
// И передать ей функцию аргументом:
Print("dog", Say) 

// Для функции есть литеральная форма синтаксиса. Функцию можно создать по месту, не декларируя и не именуя в блоке деклараций.
f := func(s string) string { return s } 
// Можно даже использовать литерал в качестве аргумента при вызове:
Print("dog", func(s string) string { return s }) 
// Это то, что ещё называют анонимной или лямбда-функцией.

// Можно написать функцию, которая возвращает функции значениями:
func Do(say bool) func(string) string {
    if say {
        return Say
    }
    return func(s string) string { return s }
} 
// И вызывать вот так:
Print("dog", Do(true)) 


// Замыкания
// Go — язык с лексической областью видимости (lexically scoped). 
// Это значит, что переменные, определённые в окружающих блоках видимости (например, глобальные переменные), доступны функции всегда, а не только на время вызова. 
// Можно считать, что функция их запоминает.
// Лексическая область видимости и анонимные функции позволяют реализовать замыкания (closure).
// Вот классический пример итератора чётных чисел, построенного на замыкании:
func Generate(seed int) func() {
    return func() {
        fmt.Println(seed) // замыкание получает внешнюю переменную seed
        seed += 2 // переменная модифицируется
    }
    
}

func main() {
    iterator := Generate(0)
    iterator()
    iterator()
    iterator()
    iterator()
    iterator()
}
// ```
// Замыкание привязывает к себе внешнюю переменную. После выхода из внешней функции `Generate` она не уничтожается, 
// а остаётся привязанной к функции замыкания, причём её значение сохраняется между вызовами функции.

// Получаем:

// ```bash
// 0
// 2
// 4
// 6
// 8 
// А вот и упоминавшиеся числа Фибоначчи, но теперь написанные с применением замыкания:
func fib() func() int {
    x1, x2 := 0, 1
    // возвращаемая функция замыкает x1, x2
    return func() int {
        x1, x2 = x2, x1+x2
        return x1
    }
}

func main() {
    f := fib() // получили функцию-замыкание. f() — захватила x1, x2. x1 = 0, x2 = 1
    fmt.Println(f()) // x1 = 1, x2 = 1
    fmt.Println(f()) // x1 = 1, x2 = 2
    fmt.Println(f()) // x1 = 2, x2 = 3
    fmt.Println(f()) // x1 = 3, x2 = 5
    fmt.Println(f()) // x1 = 5, x2 = 8
    fmt.Println(f()) // x1 = 8, x2 = 13

} 
// Получаем:
// 1
// 1
// 2
// 3
// 5
// 8
// 13 
// Такие функции иногда называют генераторами. Они выдают новое значение какой-либо последовательности при каждом вызове.
// Замыкания довольно полезные. Они позволяют просто и изящно реализовать определённые паттерны проектирования. 
// Тем не менее, чтобы эффективно использовать замыкания, надо представлять, как они работают.

// Приведём более практичный пример использования замыкания. Создадим две функции-обёртки, одна из которых будет подсчитывать количество вызовов, 
// а вторая — время исполнения функции.
// countCall — функция-обёртка для подсчёта вызовов
func countCall(f func(string)) func(string) {
    cnt := 0
    // получаем имя функции. Подробнее об этом вызове будет рассказано в следующем курсе
    funcname := runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()
    return func(s string) {
        cnt++
        fmt.Printf("Функция %s вызвана %d раз\n", funcname, cnt)
        f(s)
    }
}

// metricTimeCall — функция-обёртка для замера времени
func metricTimeCall(f func(string)) func(string) {
    return func(s string) {
        start := time.Now() // получаем текущее время
        f(s)
        fmt.Println("Execution time: ", time.Now().Sub(start)) // получаем интервал времени как разницу между двумя временными метками
    }
}

func myprint(s string) {
    fmt.Println(s)
}

func main() {

    countedPrint := countCall(myprint)
    countedPrint("Hello world")
    countedPrint("Hi")

    // обратите внимание, что мы оборачиваем уже обёрнутую функцию, а значение счётчика вызовов при этом сохраняется
    countAndMetricPrint := metricTimeCall(countedPrint)
    countAndMetricPrint("Hello")
    countAndMetricPrint("World")

}
// Результат

// Функция main.myprint вызвана 1 раз
// Hello world
// Функция main.myprint вызвана 2 раз
// Hi
// Функция main.myprint вызвана 3 раз
// Hello
// Execution time:  3.147µs
// Функция main.myprint вызвана 4 раз
// World
// Execution time:  3.16µs
 
// Вот ещё интересный пример применения замыкания. Вспомним функцию PrintAllFilesWithFilter, с которой мы недавно работали. 
// Её недостаток в том, что параметр filter передаётся при каждом рекурсивном вызове. От этого можно избавиться, используя анонимную функцию в качестве замыкания.
func PrintAllFilesWithFilterСlosure(path string, filter string) {
    // создаём переменную, содержащую функцию обхода
    // мы создаём её заранее, а не через оператор :=, чтобы замыкание могло сослаться на него
    var walk func(string)
    walk = func(path string) {
        // получаем список всех элементов в папке (и файлов, и директорий)
        files, err := ioutil.ReadDir(path)
        if err != nil {
            fmt.Println("unable to get list of files", err)
            return
        }
        //  проходим по списку
        for _, f := range files {
            // получаем имя элемента
            // filepath.Join — функция, которая собирает путь к элементу с разделителями
            filename := filepath.Join(path, f.Name())
            // печатаем имя элемента, если путь к нему содержит filter, который получим из внешнего контекста
            if strings.Contains(filename, filter) {
                fmt.Println(filename)
            }
            // если элемент — директория, то вызываем для него рекурсивно ту же функцию
            if f.IsDir() {
                walk(filename)
            }
        }
    }
    // теперь вызовем функцию walk
    walk(path)
}
 
// Теперь неизменяющийся параметр не копируется на каждом шаге рекурсии. 
// Замыкание просто ссылается на его значение, повышая скорость работы программы и снижая вероятность ошибки.


// Особенные функции
// Точка входа в программу — функция main(). Она обязательно должна существовать в единственном виде и в любой исполняемой программе на Go. 
// main() не принимает аргументов и не возвращает значений.
// В Go есть встроенные функции, например: make(), new(), len(), cap(), delete(), close(), append(), copy(), panic(), recover(). 
// Это не библиотечные функции. Они не вполне подчиняются правилам для функций пользователя. У них может не быть сигнатуры, 
// а их использование документировано в спецификации языка — основополагающем для Go документе.
// В базовом синтаксисе языка также описана вот эта функция:
func init() { … } 
// В пакете и даже в одном файле можно декларировать несколько таких функций. 
// Они будут вызваны один раз при инициализации пакета, после присвоения глобальных переменных, в том порядке, 
// в котором они предоставлены компилятору (встречаются в исходном тексте). Прямой вызов функции init() в коде программы не предусмотрен.
// Служат эти функции для создания окружения, необходимого пакету для корректной работы.
// Вот простой пример:
var name, surname string

func init() {
    name = "John"
}
func init() {
    if surname == "" {
        surname = "Doe"
    }
}
func main() {
    fmt.Println("Hello " + name + " " + surname)
} 

// Напишем конструктор типа с начальными значениями и удобными опциями. Воспользуемся подходом, 
// который предложил Роб Пайк в статье Self-referential functions and the design of options.
// В Go нет конструкторов в классическом ООП-понимании. Есть встроенные аллокаторы make() и new(), которые инициализируют поля в их нулевые значения. 
// Необходимые параметры устанавливаются литерально, присваиванием.
type Person struct {
    Name string
    Surname string
    Age int
}

john := Person{Name: "John", Surname: "Doe", Age: 21}
john.Age = 27 
// Это не очень технологично. Предположим, нам нужно инициализировать однотипные элементы значениями по умолчанию, но с возможностью задать некоторые параметры.
type Item struct {
    NoOption string
    Parameter1 string
    Parameter2 int
}
 
// Сделаем свой конструктор с опциями.
func NewItem(opts ...option) *Item {
    // инициализируем типовыми значениями
    i := &Item{
        NoOption: "usual",
        Parameter1: "default",
        Parameter2: 42,
    }
    // применяем опции в том порядке, в котором они были заявлены
    for _, opt := range opts {
        opt(i)
    }
    return i
} 
// Здесь опции — это функции, применяемые к объекту. За это подход получил название funcopts.
type option func(*Item) 
// Чтобы устанавливать параметры, будем использовать функции высшего порядка, возвращающие значениями функции option.
func Option1(option1 string) option {
    return func(i *Item) {
        i.Parameter1 = option1
    }
}
func Option2(option2 int) option {
    return func(i *Item) {
        i.Parameter2 = option2
    }
} 
// Тогда инициализация объекта конструктором будет выглядеть так:
func main() {
    // с параметрами по умолчанию
    item1 := NewItem()
    // с применением одной опции
    item2 := NewItem(Option2(70))
    // или двух
    item3 := NewItem(Option1("unusual"), Option2(99))
    // опции можно заявлять в разном порядке
    item4 := NewItem(Option2(88), Option1("rare"))
}


// Есть фигуры:
type figures int

const(
    square figures = iota // квадрат
    circle // круг
    triangle // равносторонний треугольник
) 
// Напишите функцию с такой сигнатурой:
func area(figures)(func(float64) float64, bool) 
// Функция должна возвращать:
// функцию для вычисления площади фигуры;
// true, если фигура известна;
// false, если фигура неизвестна.
// Нужно, чтобы её можно было применять так:
ar, ok := area(myFigure)
if !ok {
    fmt.Println("Ошибка")
    return
}
myArea := ar(x) 

func area(f figures) (func(float64) float64, bool) {
    switch f {
    case square:
        return func(x float64) float64 { return x * x }, true
    case circle:
        return func(x float64) float64 { return 3.142 * x * x }, true
    case triangle:
        return func(x float64) float64 { return 0.433 * x * x }, true
    default:
        return nil, false
    }
} 


// В примере этого урока мы рассматривали функцию PrintAllFilesWithFilterClosure. 
// В качестве параметра она принимает обязательную строку из пути файла, имя которого выводится на печать. 
// На её основе напишите функцию PrintFilesWithFuncFilter(path string, predicate func (string) bool).
// В качестве второго параметра принимается функция, которая проверяет свой аргумент на соответствие определённому условию. Если оно выполняется, то функция возвращает true.
// Для примера может быть передана такая функция:

// containsDot возвращает все пути, содержащие точки
func containsDot(s string) bool {
    return strings.Contains(s, ".")
} 

func PrintAllFilesWithFuncFilter(path string, predicate func(string) bool) {
    // создаём переменную, содержащую функцию обхода
    // мы создаём её заранее, а не через оператор :=, чтобы замыкание могло сослаться на него
    var walk func(string)
    walk = func(path string) {
        // получаем список всех элементов в папке (и файлов, и директорий)
        files, err := ioutil.ReadDir(path)
        if err != nil {
            fmt.Println("unable to get list of files", err)
            return
        }
        //  проходим по списку
        for _, f := range files {
            // получаем имя элемента
            // filepath.Join — функция, которая собирает путь к элементу с разделителями
            filename := filepath.Join(path, f.Name())
            // печатаем имя элемента, если predicate вернёт true
            if predicate(filename) {
                fmt.Println(filename)
            }
            // если элемент — директория, то вызываем для него рекурсивно ту же функцию
            if f.IsDir() {
                walk(filename)
            }
        }
    }
    // теперь вызовем функцию walk
    walk(path)
}



// Оператор отложенного вызова
// Открывая доступ к ресурсу (файлу, сокету, сетевому соединению), программист думает, как бы потом не забыть его закрыть. И забывает.
// Под ресурсом понимаем любой объект, который может быть открыт (получаем доступ) и закрыт (отдаём доступ). 
// Если наш код возьмёт доступ и не отдаст — будет не очень.
// Обычно в языках ООП такое решается с помощью контекстных менеджеров (Python) или деструкторов (C++, Java). 
// Однако в Gо это происходит по-другому — через механизм отложенного вызова.
// В Go есть оператор, который позволяет запланировать отложенный вызов, — это инструкция defer. 
// Мы рассматривали его кратко в уроке «Особенности языка», а сейчас разберём в подробностях.
resource := System.Acquire("resourceID")
defer System.Close(resource) 
// Оператор defer часто применяется на практике, вот только для начинающих не всегда очевидно, как он работает и какие есть подводные камни.
// Оператор defer используют внутри функций, а его операндом служит выражение вызова функции. Будем называть эти функции «отложившая» и «отложенная», чтобы избежать путаницы.
// Инструкция defer вычисляет аргументы для вызова, но вызов не делает. Вызов выполняется непосредственно перед тем, как отложившая его функция вернёт управление.
func EvaluationOrder(){
    defer fmt.Println("deferred")
    fmt.Println("evaluated")
} 
// Выведет:
// evaluated
// deferred 

// Работу оператора можно описать следующим образом.
// 1.Идёт обычное выполнение программы.
// 2.Наступает очередь выполнения оператора defer.
// 3.Вычисляются операнды отложенной функции, если такие есть.
// 4.Вызов функции вместе со значениями откладывается в специальный стек.
// 5.Выполнение функции продолжается. Если встречается оператор defer, то повторяем пункты 3 и 4.
// 6.Если встречается оператор return, то функция вычисляет его операнды и сохраняет значение в буфер.
// 7.Если стек отложенных вызовов не пустой, то извлекаем из него вызов функции и выполняем его.
// 8.Повторяем пункт 7, пока стек не опустеет.
// 8.Выходим из функции, возвращая значение из буфера.
// Важно понимать, что результат функции вычисляется до выполнения отложенных вызовов.
// Отложенных вызовов может быть несколько. Тогда они выполняются в обратном порядке, то есть начиная с того, который был отложен последним, так как вызовы складывались в стек.
fmt.Println("Hello")
for i := 1; i <= 3; i++ {
    defer fmt.Println(i)
}
fmt.Println("World") 
// Выведет:
// Hello
// World
// 3
// 2
// 1 

// Отложенная функция может возвращать значение, которое не используется. Действительно, его вернуть просто некуда.

// Также отложенная функция может быть анонимной и заданной литерально. 
// Напомним, что анонимной называется функция, задаваемая литералом по месту использования. Анонимная функция в таком случае задаётся сразу вместе с вызовом.
// В таком случае ей могут быть доступны переменные отложившей функции. Произойдёт замыкание (closure). 
// Например, если у отложившей функции есть именованное возвращаемое значение, отложенная функция может его изменить.
func unintuitive() (value string){
    defer func() {value = "На самом деле"}() // круглые скобки в конце означают, что функция вызывается
    return "Казалось бы"
} 
// Обратите внимание, это работает только с именованными возвращаемыми значениями. Следующий код выведет "Казалось бы":
func intuitive() (string){
    value := "Казалось бы"
    defer func() {value = "На самом деле"}()
    return value
} 
// В чём разница? В первом случае функция возвращает переменную value. При вычислении операнда return ей действительно присваивается значение "Казалось бы", 
// но эта переменная захвачена замыканием и изменяется в нём. После чего она и возвращается из функции.
// Во втором случае у нас есть некоторая скрытая переменная ret1, в которую при вызове оператора return копируется значение её операнда. 
// После любые действия с value уже не будут важны.
// Также распространённой ошибкой является предположение, что операнды отложенной функции будут вычислены во время её выполнения. 
// Это не так, они вычисляются при выполнении оператора defer:
func SimeFunc() {
    a := "some text"
    defer func(s string){
        fmt.Println(s)    
    }(a)
    a = "another text"
} 
// Функция напечатает "some text".

// Оператор defer чаще всего можно увидеть с парными функциями Open()/Close(), Lock()/Unlock(). 
// Его ставят сразу после захвата ресурса, чтобы точно не забыть.
// Вот классический пример:
// открываем файл
file, err := os.OpenFile("file.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
if err != nil {
    log.Fatal(err)
}
// не забываем закрыть файл
defer file.Close()
// работаем с файлом
_, err = file.WriteString("")
if err != nil {
    log.Fatal(err)
} 
// Пример применения
// Реализуем на основе функции defer замер времени выполнения функции.
// Для начала создадим функцию, которая будет измерять время выполнения и выводить его на экран.
    func metricTime (start time.Time) {
        // функция Now() возвращает текущее время, а функция Sub возвращает разницу между двумя временными метками
        fmt.Println(time.Now().Sub(start))
    } 
// Теперь применим её внутри какой-нибудь функции.
    func VeryLongTimeFunction () {
        defer     metricTime(time.Now()) // передаём в функцию metricTime значение текущего времени и откладываем её вызов до возврата
        // Какие-то долгие вычисления
    }
  
// defer и panic
// Во время выполнения программы могут возникнуть различные непредвиденные обстоятельства, из-за которых дальнейшая работа функции будет невозможна. 
// В таком случае выполнение функции немедленно прекращается, паника передаётся вызывающей функции и затем вверх по стеку, пока выполнение программы не завершится.
// Однако этот процесс меняется, если паникующая функция имеет отложенные вызовы. Они будут исполнены после выхода из функции и могут понять, что произошла паника.
// Это похоже на механизм исключений в С++ и Python, однако крайне не рекомендуется использовать panic для обычной работы. 
// Вызывать панику следует лишь тогда, когда выполнение программы действительно не может продолжаться и она должна быть завершена.

func PanicingFunc () {
    defer func(){
        if r := recover(); r != nil {  // встроенная функция recover останавливает панику и возвращает описание произошедшего
            fmt.Println("Panic is caught", r)    
        } 
    }()
    /// 
    /// 
    
    panic("Мне здесь совсем ничего не нравится!") 
    // встроенная функция panic () вызывает панику у функции. 
    // в качестве аргумента ей принято передавать причину паники. Именно она будет возвращена функцией recover
    
}
 
// Без применения оператора defer остановить панику было бы невозможно. Он позволяет вклиниться в стек вызовов функций и остановить её. 

// Используя defer, напишите функцию, которая меняет эту переменную и выводит на экран её новое значение. Потом она должна вернуть всё как было.

package main

import (
    "fmt"
)
// глобальная переменная равна 5
var Global = 5

func UseGlobal() {
    defer func(checkout int) {
        Global = checkout // присваиваем Global значение аргумента
    }(Global) // копируем значение Global в аргументы функции
    Global = 42 // Изменяем Global  
    fmt.Println(Global)
    // Здесь будет вызвана отложенная функция
}

func main() {
    fmt.Println(Global)
    UseGlobal()
    fmt.Println(Global)
}

