Связь пакетов и файловой системы
В прошлом уроке вы узнали, что пакеты в Go — это директории с исходниками. В этом расскажем, каким образом положение исходников в файловой системе определяет пути для импорта.
Если не пользоваться модулями (о них пойдёт речь в следующем уроке), то путь для импорта пакета — это путь к директории пакета относительно ${GOPATH}/src.
При установке компилятора он создаёт переменную окружения GOPATH, которая указывает путь к папке установки.
Напомним, что переменные окружения — это переменные, которые хранятся в вашей операционной системе и доступны программам. Посмотреть список переменных окружения можно командой go env, какую-то конкретную — например, go env GOPATH, а изменить переменную окружения — через команду go env -w <Имя переменной>=<новое значение>.
Допустим, нужно создать пакет для какого-нибудь финансового проекта. Назовём его finance.
По мере написания кода этого пакета выясняется, что в разных местах требуются одни и те же математические функции. Тогда выносим их в отдельный подпакет finmath, после чего дерево пакетов в файловой системе будет выглядеть примерно так (названия файлов могут быть другие):
finance
├── money_calculation.go
└── finmath
    └── arithmetics.go 
Если считать от GOPATH, то вот так:
GOPATH
└── src
    └── finance
        ├── money_calculation.go
        └── finmath
            └── arithmetics.go 
Теперь можно импортировать пакеты finance и finmath по путям "finance" и "finance/finmath" соответственно:
package main

import (
    "fmt"

    "finance"
    "finance/finmath"
)

func main() {
    fmt.Println(finance.GetMostRecentBill())
    fmt.Println(finmath.Add(1, 2))
} 
Путь к пакетам, которые хостятся в системах контроля версий, обычно имеет вид ${GOPATH}/src/<VCS_URL>/<USER_NAME>/<REPO_NAME>, а что касается, например, библиотеки тестирования testify, то ${GOPATH}/src/github.com/stretchr/testify.
В Go на уровне компилятора запрещены циклические импорты. Если несколько пакетов зациклились друг на друга, нужно либо перекладывать проблемный код в отдельные пакеты, либо пересматривать логику работы приложения. Циклический импорт — это сигнал о том, что в приложении есть архитектурная проблема. Если архитектура приложения выстроена правильно, то циклические импорты не должны возникать.
О том, как правильно выстраивать архитектуру приложения, вы можете узнать на других наших курсах.
Задание
Напишите функцию сложения целых чисел AddInts(a, b int) int. Разместите файл с этой функцией в локальной файловой системе так, чтобы приведённый ниже код успешно отработал. Изменять приведённый код нельзя.
package main

import (
    "fmt"

    "toppackage/middlepackage/bottompackage/mathxxx"
)

func main() {
    if sum := mathxxx.AddInts(3, 2); sum != 5 {
        panic(fmt.Sprintf("sum must be equal 5; got %d", sum))
    }

    fmt.Println("Well done!")
} 